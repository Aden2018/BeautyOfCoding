#include <iostream>
#include <algorithm>

//问题:有很多的ID，正常的是出现两次，怎么找到只出现一次的ID
//假设只有一个只出现一次的:

//解法1:
//遍历，记下每个id出现的次数,时间O(n),空间O(n)

//解法2:
//遍历，变长数组，出现两次的移出去，空间复杂度最好情况下能够O(1)，最后留下一个数就是要找的ID

//解法3:
//遍历，对于每个变量依次异或，这样，最终的结果就是要找的ID,空间O(1)

//如果有两个ID只出现了一次

//解法4:
//重复上面的做法，若这两个ID相等，就是这个ID一次都没出现，那么异或结果还是0，没法求解。
//如果不等，那么最后异或结果不等于0，假设为0101,那么这两个数在结果的非零位上肯定是一个1一个0,
//比如我们用第二位1对原始所有ID进行分类，分类后，再对每个组进行异或，每个组剩下的即是结果。

//解法5:（有点扯，要知道所有原来的ID）
//对于只有一个只出现一次的情况:原始所有ID相加，求和，现在ID相加，相减，则是结果。
//有两个只出现一次:原始ID求和，相减，x+y=sum
//再构建一个方程，比如原始ID相乘，x*y=product即可求解。


int main()
{
	int arr[] = { 1,2,2,3,3,4,5,4,7,9,7,9,1 }; //对于异或的验证，这里5只出现一次，其他出现两次
	int n = sizeof(arr) / sizeof(arr[0]);
	int res = arr[0];
	for (int i = 1; i < n; ++i)
	{
		res ^= arr[i];
	}

	std::cout << res << std::endl;
	return 0;

}